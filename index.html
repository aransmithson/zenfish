<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Zen Pond</title>
<style>
html,body{
  margin:0;
  height:100%;
  overflow:hidden;
  background:#021018;
}
canvas{
  display:block;
  width:100vw;
  height:100vh;
}
</style>
</head>
<body>
<canvas id="c"></canvas>
<script>
(() => {
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");

  let W, H;
  const settings = {
    sound: true,
    rain: false
  };

  // Game start gate (hints begin timing after first non-mute interaction)
  let gameStarted = true;

  function resize() {
    const dpr = Math.min(2, window.devicePixelRatio || 1);
    W = innerWidth;
    H = innerHeight;
    canvas.width = W * dpr;
    canvas.height = H * dpr;
    canvas.style.width = W + "px";
    canvas.style.height = H + "px";
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  addEventListener("resize", resize);
  resize();

  // Automatic rain cycling
  let rainCycleTimer = 0;
  let rainDuration = 0;
  let isRaining = false;
  const RAIN_BREAK_DURATION = 20; // Wait 20 seconds between rain cycles

  function updateRainCycle(dt) {
    rainCycleTimer += dt;

    if (isRaining) {
      // Currently raining - check if duration is over
      if (rainCycleTimer >= rainDuration) {
        isRaining = false;
        settings.rain = false;
        rainCycleTimer = 0;
      }
    } else {
      // Not raining - check if it's time to rain again
      if (rainCycleTimer >= RAIN_BREAK_DURATION) {
        isRaining = true;
        settings.rain = true;
        rainDuration = rand(5, 20); // Rain for 5-20 seconds
        rainCycleTimer = 0;
      }
    }
  }

  const rand = (a, b) => a + Math.random() * (b - a);
  const dist2 = (ax, ay, bx, by) => {
    let dx = bx - ax, dy = by - ay;
    return dx * dx + dy * dy;
  };

  /* =============================
     BACKGROUND
  ============================= */

  function drawWater() {
    const g = ctx.createLinearGradient(0, 0, 0, H);
    g.addColorStop(0, "#0a2a43");
    g.addColorStop(0.5, "#062033");
    g.addColorStop(1, "#021018");
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, W, H);
  }

  /** =============================
     AUDIO
  ============================= */

  let audioCtx = null;

  let dropSound = null;
  let ambientBuffer = null;
  let rainBuffer = null;

  let ambientSource = null;
  let ambientGain = null;

  let rainSource = null;
  let rainGain = null;

  function initAudio() {
    if (audioCtx) return;

    audioCtx = new (window.AudioContext || window.webkitAudioContext)();

    Promise.all([
      fetch('drop.mp3').then(r => r.arrayBuffer()),
      fetch('ambient.mp3').then(r => r.arrayBuffer()),
      fetch('rain.mp3').then(r => r.arrayBuffer())
    ])
      .then(buffers => Promise.all(buffers.map(b => audioCtx.decodeAudioData(b))))
      .then(decoded => {
        dropSound = decoded[0];
        ambientBuffer = decoded[1];
        rainBuffer = decoded[2];

        startAmbient();
      })
      .catch(err => console.log('Sound files not loaded:', err));
  }

  function startAmbient() {
    if (!audioCtx || !ambientBuffer || ambientSource) return;

    ambientSource = audioCtx.createBufferSource();
    ambientSource.buffer = ambientBuffer;
    ambientSource.loop = true;

    ambientGain = audioCtx.createGain();
    ambientGain.gain.value = 0.5;

    ambientSource.connect(ambientGain).connect(audioCtx.destination);
    ambientSource.start();
  }

  function ensureRainSound() {
    if (!audioCtx || !rainBuffer) return;
    if (rainSource) return;

    rainSource = audioCtx.createBufferSource();
    rainSource.buffer = rainBuffer;
    rainSource.loop = true;

    rainGain = audioCtx.createGain();
    rainGain.gain.value = 0; // fade in from 0

    rainSource.connect(rainGain).connect(audioCtx.destination);
    rainSource.start();
  }

  function stopRainSound() {
    if (!rainSource) return;
    try { rainSource.stop(); } catch {}
    try { rainSource.disconnect(); } catch {}
    rainSource = null;
    rainGain = null;
  }

  function updateRainAudio(dt) {
    if (!audioCtx || !settings.sound) return;

    // If rain toggled on, ensure source exists and fade in
    if (settings.rain) {
      ensureRainSound();
      if (rainGain) {
        const target = 0.4;
        rainGain.gain.value += (target - rainGain.gain.value) * 0.02;
      }
    } else {
      // Fade out and stop when nearly silent
      if (rainGain) {
        rainGain.gain.value += (0 - rainGain.gain.value) * 0.02;
        if (rainGain.gain.value < 0.01) stopRainSound();
      }
    }
  }

  function playDroplet(x) {
    if (!audioCtx || !settings.sound || !dropSound) return;

    if (audioCtx.state === 'suspended') {
      audioCtx.resume();
    }

    const source = audioCtx.createBufferSource();
    const gain = audioCtx.createGain();
    const pan = audioCtx.createStereoPanner();

    source.buffer = dropSound;
    gain.gain.value = 0.4;
    pan.pan.value = (x / W) * 2 - 1;

    source.connect(gain).connect(pan).connect(audioCtx.destination);
    source.start();
  }

  /* =============================
     PAGE VISIBILITY - PAUSE AUDIO WHEN MINIMIZED
  ============================= */

  document.addEventListener('visibilitychange', () => {
    if (!audioCtx) return;

    if (document.hidden) {
      // Page is hidden (minimized, tab switched, etc) - suspend audio
      if (audioCtx.state === 'running') {
        audioCtx.suspend();
      }
    } else {
      // Page is visible again - resume audio if sound is enabled
      if (audioCtx.state === 'suspended' && settings.sound) {
        audioCtx.resume();
      }
    }
  });

  /* =============================
     UI: MUTE ICON + HINTS
  ============================= */

  const muteIcon = {
    size: 26,
    padding: 18
  };

  function drawMuteIcon() {
    const x = W - muteIcon.padding - muteIcon.size;
    const y = muteIcon.padding;

    ctx.save();
    ctx.globalAlpha = 0.55;

    ctx.shadowColor = "rgba(255,255,255,0.18)";
    ctx.shadowBlur = 8;

    ctx.strokeStyle = "rgba(255,255,255,0.7)";
    ctx.lineWidth = 1.5;

    // Speaker
    ctx.beginPath();
    ctx.moveTo(x + 4, y + muteIcon.size * 0.35);
    ctx.lineTo(x + 10, y + muteIcon.size * 0.35);
    ctx.lineTo(x + 16, y + muteIcon.size * 0.2);
    ctx.lineTo(x + 16, y + muteIcon.size * 0.8);
    ctx.lineTo(x + 10, y + muteIcon.size * 0.65);
    ctx.lineTo(x + 4, y + muteIcon.size * 0.65);
    ctx.closePath();
    ctx.stroke();

    if (!settings.sound) {
      // Cross
      ctx.beginPath();
      ctx.moveTo(x + 18, y + 6);
      ctx.lineTo(x + 24, y + 20);
      ctx.moveTo(x + 24, y + 6);
      ctx.lineTo(x + 18, y + 20);
      ctx.stroke();
    }

    ctx.restore();
  }

  // Hint system (starts after gameStarted)
  let hintTimer = 0;
  let firstTapOccurred = false;

  const hintState = {
    phase: 0,   // 0 waiting, 1 first, 2 gap, 3 second, 4 done
    alpha: 0,
    yOffset: 0,
    shimmer: 0
  };

  function updateHints(dt) {
    if (!gameStarted) return;

    hintTimer += dt;
    hintState.shimmer += dt * 2;

    const FADE_IN = 2.0;
    const HOLD = 2.5;
    const FADE_OUT = 2.0;
    const START_DELAY = 2.0;

    // Wait before first hint
    if (hintState.phase === 0 && hintTimer > START_DELAY) {
      hintState.phase = 1;
      hintTimer = 0;
    }

    // FIRST MESSAGE
    if (hintState.phase === 1) {
      // Disappear immediately on first tap
      if (firstTapOccurred) {
        hintState.phase = 2;
        hintTimer = 0;
        hintState.alpha = 0;
        hintState.yOffset = 0;
        return;
      }

      if (hintTimer < FADE_IN) {
        hintState.alpha = hintTimer / FADE_IN;
      } else if (hintTimer < FADE_IN + HOLD) {
        hintState.alpha = 1;
      } else if (hintTimer < FADE_IN + HOLD + FADE_OUT) {
        hintState.alpha = 1 - (hintTimer - FADE_IN - HOLD) / FADE_OUT;
      } else {
        hintState.phase = 2;
        hintTimer = 0;
        hintState.alpha = 0;
      }
    }

    // GAP BEFORE SECOND
    if (hintState.phase === 2) {
      // Only show second if rain hasn't started
      if (settings.rain) {
        hintState.phase = 4;
        hintState.alpha = 0;
        hintState.yOffset = 0;
        return;
      }

      if (hintTimer > 1.5) {
        hintState.phase = 3;
        hintTimer = 0;
      }
    }

    // SECOND MESSAGE
    if (hintState.phase === 3) {
      if (hintTimer < FADE_IN) {
        hintState.alpha = hintTimer / FADE_IN;
      } else if (hintTimer < FADE_IN + HOLD) {
        hintState.alpha = 1;
      } else if (hintTimer < FADE_IN + HOLD + FADE_OUT) {
        hintState.alpha = 1 - (hintTimer - FADE_IN - HOLD) / FADE_OUT;
      } else {
        hintState.phase = 4;
        hintState.alpha = 0;
      }
    }

    // Soft upward drift while visible
    hintState.yOffset = -8 * hintState.alpha;
  }

  function drawHints() {
    if (hintState.phase === 0 || hintState.phase === 4) return;

    ctx.save();
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.font = "14px sans-serif";

    const shimmer = Math.sin(hintState.shimmer) * 0.15 + 0.85;
    ctx.globalAlpha = hintState.alpha * 0.7 * shimmer;

    ctx.shadowColor = "rgba(255,255,255,0.4)";
    ctx.shadowBlur = 12 * hintState.alpha;

    let text = "";
    let color = "rgba(255,255,255,0.9)";

    if (hintState.phase === 1) {
      text = "tap to feed";
      color = "rgba(255,255,255,0.95)";
    } else if (hintState.phase === 3) {
      text = "it might rain later";
      color = "rgba(200,220,255,0.95)";
    } else {
      ctx.restore();
      return;
    }

    ctx.fillStyle = color;
    ctx.fillText(text, W / 2, H / 2 + hintState.yOffset);

    ctx.restore();
  }

  /* =============================
     FOOD + SAFE RIPPLES
  ============================= */

  const foods = [];
  const ripples = [];
  const spookZones = []; // Zones that scare fish away
  let flow = 0;

  canvas.addEventListener("pointerdown", e => {
    // --- Mute icon click detection (do not start game / hints) ---
    const iconX = W - muteIcon.padding - muteIcon.size;
    const iconY = muteIcon.padding;
    if (
      e.clientX > iconX &&
      e.clientX < iconX + muteIcon.size &&
      e.clientY > iconY &&
      e.clientY < iconY + muteIcon.size
    ) {
      settings.sound = !settings.sound;

      if (audioCtx) {
        if (!settings.sound) audioCtx.suspend();
        else audioCtx.resume();
      }
      return;
    }



    // Dismiss first hint only if it's currently visible
    if (hintState.phase === 1) {
      firstTapOccurred = true;
    }

    
    initAudio();

    // Check if clicking on a flower first
    let clickedFlower = false;
    for (const f of flowers) {
      const dx = e.clientX - f.x;
      const dy = e.clientY - f.y;
      const distance = Math.sqrt(dx * dx + dy * dy);

      // Check if click is within flower radius (considering size and petals)
      if (distance < f.size * 1.5) {
        // Trigger spin
        f.spinning = true;
        f.currentRotSpeed = rand(8, 12); // Fast spin speed

        // Add spook zone to scare nearby fish
        spookZones.push({
          x: f.x,
          y: f.y,
          life: 0,
          maxLife: 1.2, // How long the spook effect lasts
          radius: 180   // How far the spook effect reaches
        });

        clickedFlower = true;
        break; // Only spin one flower per click
      }
    }

    // If didn't click a flower, add food and ripple as normal
    if (!clickedFlower) {
      foods.push({
        x: e.clientX,
        y: e.clientY,
        size: 8
      });
      ripples.push({
        x: e.clientX,
        y: e.clientY,
        life: 0,
        maxLife: 2.0,
        baseRadius: 5,
        isRain: true
      });
      playDroplet(e.clientX);
    }
  });

  function updateFood(dt) {
    flow += dt * 0.2;
    for (const f of foods) {
      // gentle horizontal drift
      f.x += Math.sin(flow + f.y * 0.02) * 8 * dt;

      // slow sinking
      f.y += 10 * dt;

      // subtle bobbing
      f.y += Math.sin(flow * 2 + f.x * 0.01) * 2 * dt;

      // remove if sunk too low
      if (f.y > H + 20) {
        foods.splice(foods.indexOf(f), 1);
      }
    }
  }

  function updateRipples(dt) {
    for (const r of ripples) r.life += dt;

    for (let i = ripples.length - 1; i >= 0; i--) {
      if (ripples[i].life > ripples[i].maxLife) {
        ripples.splice(i, 1);
      }
    }
  }

  function updateSpookZones(dt) {
    for (const z of spookZones) z.life += dt;

    for (let i = spookZones.length - 1; i >= 0; i--) {
      if (spookZones[i].life > spookZones[i].maxLife) {
        spookZones.splice(i, 1);
      }
    }
  }

  /* =============================
     RAIN SYSTEM
  ============================= */

  const rainDrops = [];
  const MAX_RAIN_DROPS = 5;
  let rainTimer = 0;

  function spawnRainDrop() {
    if (rainDrops.length >= MAX_RAIN_DROPS) return;

    const targetY = rand(H * 0.2, H * 0.95); // Random height where drop will hit

    rainDrops.push({
      x: rand(W * 0.1, W * 0.9),
      y: -20,
      targetY: targetY,
      speed: rand(300, 450),
      length: rand(15, 25),
      opacity: rand(0.4, 0.7)
    });
  }

  function updateRain(dt) {
    if (!settings.rain) {
      rainDrops.length = 0;
      return;
    }

    // Spawn new rain drops periodically
    rainTimer += dt;
    if (rainTimer > rand(0.3, 0.6)) {
      spawnRainDrop();
      rainTimer = 0;
    }

    // Update existing rain drops
    for (let i = rainDrops.length - 1; i >= 0; i--) {
      const drop = rainDrops[i];
      drop.y += drop.speed * dt;

      // Check if drop hit the water surface (its target height)
      if (drop.y >= drop.targetY) {
        // Create rain ripple at the target height
        ripples.push({
          x: drop.x,
          y: drop.targetY,
          life: 0,
          maxLife: 2.0,
          baseRadius: 5,
          isRain: true
        });

        // Remove the drop
        rainDrops.splice(i, 1);

        // Optional: play subtle sound
        if (Math.random() < 0.3) {
          playDroplet(drop.x);
        }
      }
    }
  }

  function drawRain() {
    if (!settings.rain) return;

    ctx.save();
    ctx.lineCap = 'round';

    for (const drop of rainDrops) {
      ctx.strokeStyle = `rgba(200, 220, 255, ${drop.opacity})`;
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(drop.x, drop.y);
      ctx.lineTo(drop.x, drop.y + drop.length);
      ctx.stroke();
    }

    ctx.restore();
  }

  /* =============================
     FISH
  ============================= */

  class Fish {
    constructor() {
      this.x = rand(0, W);
      this.y = rand(0, H);
      const a = rand(0, Math.PI * 2);
      this.baseSpeed = rand(45, 75);
      this.sizeScale = rand(0.8, 1.2);
      this.vx = Math.cos(a) * this.baseSpeed;
      this.vy = Math.sin(a) * this.baseSpeed;
      this.tail = rand(0, Math.PI * 2);
      this.speedMultiplier = 1.0; // For fleeing speed boost

      // Classic koi color patterns
      const patterns = [
        { base: '#ffffff', accent: '#ff6b35', spots: true },  // Kohaku (white + red)
        { base: '#ffd700', accent: '#ff8c00', spots: false }, // Gold
        { base: '#ffffff', accent: '#ff1744', spots: true },  // White + deep red
        { base: '#ffe0b5', accent: '#ff6f00', spots: true },  // Cream + orange
        { base: '#ff6b6b', accent: '#8b0000', spots: false }, // Red
        { base: '#ffffff', accent: '#000000', spots: true },  // Shiro Utsuri (white + black)
      ];

      const pattern = patterns[Math.floor(Math.random() * patterns.length)];
      this.baseColor = pattern.base;
      this.accentColor = pattern.accent;
      this.hasSpots = pattern.spots;

      // Generate random spots if applicable
      this.spots = [];
      if (this.hasSpots) {
        const numSpots = Math.floor(rand(2, 5));
        for (let i = 0; i < numSpots; i++) {
          this.spots.push({
            x: rand(-8, 4),
            y: rand(-4, 4),
            size: rand(3, 7) * this.sizeScale
          });
        }
      }
    }

    update(dt, fishes) {
      // --- Boids-style flocking (cohesion, alignment, separation) ---
      const perception = 90;
      const separationDist = 34;
      const perception2 = perception * perception;
      const separation2 = separationDist * separationDist;

      let cohX = 0, cohY = 0, aliX = 0, aliY = 0, sepX = 0, sepY = 0;
      let count = 0;

      for (const other of fishes) {
        if (other === this) continue;
        const d2v = dist2(this.x, this.y, other.x, other.y);
        if (d2v > perception2) continue;

        count++;
        cohX += other.x;
        cohY += other.y;
        aliX += other.vx;
        aliY += other.vy;

        if (d2v < separation2 && d2v > 0.0001) {
          const dx = this.x - other.x;
          const dy = this.y - other.y;
          const inv = 1 / d2v;
          sepX += dx * inv;
          sepY += dy * inv;
        }
      }

      // Helper to limit a vector magnitude
      const limit = (x, y, max) => {
        const m = Math.hypot(x, y) || 1;
        if (m <= max) return [x, y];
        const s = max / m;
        return [x * s, y * s];
      };

      let steerX = 0;
      let steerY = 0;

      if (count > 0) {
        // Cohesion
        cohX = cohX / count - this.x;
        cohY = cohY / count - this.y;
        let m = Math.hypot(cohX, cohY) || 1;
        cohX = (cohX / m) * this.baseSpeed - this.vx;
        cohY = (cohY / m) * this.baseSpeed - this.vy;
        [cohX, cohY] = limit(cohX, cohY, 120);

        // Alignment
        aliX /= count;
        aliY /= count;
        m = Math.hypot(aliX, aliY) || 1;
        aliX = (aliX / m) * this.baseSpeed - this.vx;
        aliY = (aliY / m) * this.baseSpeed - this.vy;
        [aliX, aliY] = limit(aliX, aliY, 140);

        // Separation
        m = Math.hypot(sepX, sepY) || 1;
        sepX = (sepX / m) * this.baseSpeed - this.vx;
        sepY = (sepY / m) * this.baseSpeed - this.vy;
        [sepX, sepY] = limit(sepX, sepY, 180);

        steerX += cohX * 0.55 + aliX * 0.75 + sepX * 1.15;
        steerY += cohY * 0.55 + aliY * 0.75 + sepY * 1.15;
      }

      // --- Food attraction ---
      let nearest = null;
      let nearestDist = Infinity;

      for (const f of foods) {
        const d2v = dist2(this.x, this.y, f.x, f.y);
        if (d2v < nearestDist) {
          nearestDist = d2v;
          nearest = f;
        }
      }

      if (nearest) {
        const dx = nearest.x - this.x;
        const dy = nearest.y - this.y;
        const d = Math.hypot(dx, dy) || 1;
        const pull = 220 * (1 - Math.min(d / 420, 1));
        steerX += (dx / d) * pull;
        steerY += (dy / d) * pull;

        if (d < 15) {
          nearest.size -= 40 * dt;
          if (nearest.size <= 0) {
            foods.splice(foods.indexOf(nearest), 1);
          }
        }
      }

      // --- Spook avoidance ---
      let isSpooked = false;
      for (const zone of spookZones) {
        const dx = this.x - zone.x;
        const dy = this.y - zone.y;
        const d = Math.hypot(dx, dy) || 1;

        if (d < zone.radius) {
          isSpooked = true;
          const fadeOut = 1 - (zone.life / zone.maxLife);
          const distanceFactor = 1 - (d / zone.radius);
          const fleeStrength = 400 * fadeOut * distanceFactor;

          steerX += (dx / d) * fleeStrength;
          steerY += (dy / d) * fleeStrength;
        }
      }

      const targetMultiplier = isSpooked ? 1.3 : 1.0;
      const easeSpeed = isSpooked ? 0.25 : 0.03;
      this.speedMultiplier += (targetMultiplier - this.speedMultiplier) * easeSpeed;

      // Gentle wander
      steerX += Math.cos(this.tail * 0.6) * 18;
      steerY += Math.sin(this.tail * 0.6) * 18;

      this.vx += steerX * dt;
      this.vy += steerY * dt;

      // Keep speed steady but apply multiplier for fleeing
      const speed = Math.hypot(this.vx, this.vy) || 1;
      const target = this.baseSpeed * this.speedMultiplier;
      this.vx = (this.vx / speed) * target;
      this.vy = (this.vy / speed) * target;

      this.x += this.vx * dt;
      this.y += this.vy * dt;

      if (this.x < 0) this.x = W;
      if (this.x > W) this.x = 0;
      if (this.y < 0) this.y = H;
      if (this.y > H) this.y = 0;

      this.tail += dt * 8 * this.speedMultiplier;
    }

    draw() {
      const ang = Math.atan2(this.vy, this.vx);
      ctx.save();
      ctx.translate(this.x, this.y);
      ctx.rotate(ang);

      // Shadow
      ctx.save();
      ctx.globalAlpha = 0.2;
      ctx.fillStyle = '#000000';
      ctx.beginPath();
      ctx.ellipse(1, 4, 11 * this.sizeScale, 5 * this.sizeScale, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();

      // Body gradient
      const bodyGradient = ctx.createRadialGradient(2, -1, 0, 0, 0, 12 * this.sizeScale);
      bodyGradient.addColorStop(0, this.baseColor);
      bodyGradient.addColorStop(0.7, this.baseColor);

      // Convert hex accent to rgba-ish (kept from original file)
      bodyGradient.addColorStop(1, this.accentColor.replace(')', ', 0.3)').replace('#', 'rgba(').replace(/^rgba\(([^,]+)/, (m, hex) => {
        const r = parseInt(hex.slice(0, 2), 16);
        const g = parseInt(hex.slice(2, 4), 16);
        const b = parseInt(hex.slice(4, 6), 16);
        return `rgba(${r}, ${g}, ${b}`;
      }));

      ctx.fillStyle = bodyGradient;
      ctx.beginPath();
      ctx.ellipse(0, 0, 12 * this.sizeScale, 6 * this.sizeScale, 0, 0, Math.PI * 2);
      ctx.fill();

      // Spots
      if (this.hasSpots) {
        ctx.fillStyle = this.accentColor;
        for (const spot of this.spots) {
          ctx.globalAlpha = 0.8;
          ctx.beginPath();
          ctx.ellipse(spot.x, spot.y, spot.size, spot.size * 0.8, rand(0, Math.PI), 0, Math.PI * 2);
          ctx.fill();
        }
        ctx.globalAlpha = 1;
      }

      // Scales texture
      ctx.save();
      ctx.globalAlpha = 0.15;
      ctx.strokeStyle = this.accentColor;
      ctx.lineWidth = 0.5;
      for (let i = -8; i < 8; i += 3) {
        for (let j = -4; j < 4; j += 2.5) {
          ctx.beginPath();
          ctx.arc(i, j, 1.5 * this.sizeScale, 0, Math.PI * 2);
          ctx.stroke();
        }
      }
      ctx.restore();

      // Pectoral fins (kept from original)
      ctx.globalAlpha = 0.8;
      const finWaggle = Math.sin(this.tail * 0.8) * 3 * this.sizeScale;
      const finOffsetX = 6 * this.sizeScale;

      const finGradient = ctx.createRadialGradient(finOffsetX, 0, 0, finOffsetX, 0, 16 * this.sizeScale);
      finGradient.addColorStop(0, this.baseColor);
      finGradient.addColorStop(1, this.accentColor.replace(')', ', 0.4)').replace('#', 'rgba(').replace(/^rgba\(([^,]+)/, (m, hex) => {
        const r = parseInt(hex.slice(0, 2), 16);
        const g = parseInt(hex.slice(2, 4), 16);
        const b = parseInt(hex.slice(4, 6), 16);
        return `rgba(${r}, ${g}, ${b}`;
      }));
      ctx.fillStyle = finGradient;

      // Top fin
      ctx.beginPath();
      ctx.moveTo(finOffsetX, -3 * this.sizeScale);
      ctx.quadraticCurveTo(-16 * this.sizeScale, -14 * this.sizeScale + finWaggle, -4 * this.sizeScale, -2 * this.sizeScale);
      ctx.quadraticCurveTo(2 * this.sizeScale, -6 * this.sizeScale, finOffsetX, -3 * this.sizeScale);
      ctx.fill();

      // Bottom fin
      ctx.beginPath();
      ctx.moveTo(finOffsetX, 3 * this.sizeScale);
      ctx.quadraticCurveTo(-16 * this.sizeScale, 14 * this.sizeScale - finWaggle, -4 * this.sizeScale, 2 * this.sizeScale);
      ctx.quadraticCurveTo(2 * this.sizeScale, 6 * this.sizeScale, finOffsetX, 3 * this.sizeScale);
      ctx.fill();

      ctx.globalAlpha = 1;

      // Tail
      const tailSwish = Math.sin(this.tail) * 6 * this.sizeScale;
      const tailGradient = ctx.createLinearGradient(-12 * this.sizeScale, 0, -22 * this.sizeScale, 0);
      tailGradient.addColorStop(0, this.baseColor);
      tailGradient.addColorStop(1, this.accentColor);

      ctx.fillStyle = tailGradient;
      ctx.globalAlpha = 0.9;
      ctx.beginPath();
      ctx.moveTo(-12 * this.sizeScale, 0);
      ctx.lineTo(-22 * this.sizeScale, -6 * this.sizeScale + tailSwish);
      ctx.lineTo(-22 * this.sizeScale, 6 * this.sizeScale + tailSwish);
      ctx.closePath();
      ctx.fill();
      ctx.globalAlpha = 1;

      // Eye
      ctx.fillStyle = '#000000';
      ctx.beginPath();
      ctx.arc(8 * this.sizeScale, -1.5 * this.sizeScale, 1.2 * this.sizeScale, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
      ctx.beginPath();
      ctx.arc(8.3 * this.sizeScale, -1.8 * this.sizeScale, 0.5 * this.sizeScale, 0, Math.PI * 2);
      ctx.fill();

      ctx.restore();
    }
  }

  const fishes = [];
  for (let i = 0; i < 25; i++) fishes.push(new Fish());

  /* =============================
     FLOWERS
  ============================= */

  const flowers = [];
  for (let i = 0; i < 12; i++) {
    const baseRotSpeed = rand(0.1, 0.6);
    flowers.push({
      x: rand(0, W),
      y: rand(0, H),
      rot: rand(0, Math.PI * 2),
      driftX: rand(-10, 10),
      driftY: rand(5, 20),
      petals: Math.floor(rand(5, 9)),
      size: rand(8, 24),
      rotSpeed: baseRotSpeed,
      baseRotSpeed: baseRotSpeed,
      currentRotSpeed: baseRotSpeed,
      spinning: false,
      color: Math.random() < 0.5
        ? "rgba(255,255,255,0.95)"
        : "rgba(255,182,193,0.9)"
    });
  }

  function updateFlowers(dt) {
    for (const f of flowers) {
      f.x += f.driftX * dt;
      f.y += f.driftY * dt;

      if (f.spinning) {
        f.currentRotSpeed = f.currentRotSpeed * 0.98;
        if (f.currentRotSpeed <= f.baseRotSpeed * 1.1) {
          f.spinning = false;
          f.currentRotSpeed = f.baseRotSpeed;
        }
      }

      f.rot += dt * f.currentRotSpeed;

      if (f.y > H + 50) {
        f.y = -50;
        f.x = rand(0, W);
      }

      if (f.x < -50) f.x = W + 50;
      if (f.x > W + 50) f.x = -50;
    }
  }

  function drawFlowers() {
    for (const f of flowers) {
      // Shadow
      ctx.save();
      ctx.translate(f.x + 15, f.y + 15);
      ctx.rotate(f.rot);
      ctx.fillStyle = "rgba(0, 0, 0, 0.2)";

      for (let i = 0; i < f.petals; i++) {
        ctx.save();
        ctx.rotate((Math.PI * 2 / f.petals) * i);
        ctx.beginPath();
        ctx.ellipse(f.size * 0.6, 0, f.size, f.size * 0.5, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }
      ctx.restore();

      // Main flower
      ctx.save();
      ctx.translate(f.x, f.y);
      ctx.rotate(f.rot);

      ctx.shadowColor = "rgba(0,0,0,0.15)";
      ctx.shadowBlur = 10;

      for (let i = 0; i < f.petals; i++) {
        ctx.save();
        ctx.rotate((Math.PI * 2 / f.petals) * i);
        ctx.fillStyle = f.color;
        ctx.beginPath();
        ctx.ellipse(f.size * 0.6, 0, f.size, f.size * 0.5, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }

      ctx.fillStyle = "rgba(255,220,120,0.95)";
      ctx.beginPath();
      ctx.arc(0, 0, f.size * 0.5, 0, Math.PI * 2);
      ctx.fill();

      ctx.restore();
    }
  }

  /* =============================
     LOOP
  ============================= */

  let last = performance.now();

  function loop(now) {
    const dt = Math.min(0.033, (now - last) / 1000);
    last = now;

    drawWater();
    updateRainCycle(dt);

    updateFood(dt);
    updateRipples(dt);
    updateSpookZones(dt);
    updateFlowers(dt);
    updateRain(dt);

    // Audio follow rain state
    updateRainAudio(dt);

    // Hint timing starts only after first interaction
    updateHints(dt);

    for (const f of fishes) f.update(dt, fishes);

    /* Ripple drawing - differentiate rain vs click */
    for (const r of ripples) {
      const t = r.life / r.maxLife;

      if (r.isRain) {
        const ease = 1 - Math.pow(1 - t, 3);
        const radius = r.baseRadius + ease * 60;
        const alpha = (1 - t) * 0.6;

        ctx.save();
        ctx.lineWidth = 1.5 * (1 - t);
        ctx.strokeStyle = `rgba(200, 220, 255, ${alpha})`;

        ctx.beginPath();
        ctx.arc(r.x, r.y, radius, 0, Math.PI * 2);
        ctx.stroke();

        if (radius > 15) {
          ctx.strokeStyle = `rgba(200, 220, 255, ${alpha * 0.5})`;
          ctx.lineWidth = 1 * (1 - t);
          ctx.beginPath();
          ctx.arc(r.x, r.y, radius * 0.6, 0, Math.PI * 2);
          ctx.stroke();
        }

        ctx.restore();
      } else {
        const ease = 1 - Math.pow(1 - t, 2);
        const radius = r.baseRadius + ease * 220;
        const alpha = 1 - t;

        ctx.save();
        ctx.lineWidth = 2 * (1 - t);
        ctx.strokeStyle = `rgba(255,255,255,${alpha*0.5})`;
        ctx.shadowColor = `rgba(255,255,255,${alpha*0.3})`;
        ctx.shadowBlur = 20 * (1 - t);

        for (let i = 0; i < 3; i++) {
          const ringRadius = radius - i * 18;
          if (ringRadius > 0) {
            ctx.beginPath();
            ctx.arc(r.x, r.y, ringRadius, 0, Math.PI * 2);
            ctx.stroke();
          }
        }

        ctx.restore();
      }
    }

    for (const f of foods) {
      ctx.save();

      // slight squash for natural pellet feel
      ctx.translate(f.x, f.y);
      ctx.rotate(Math.sin(flow + f.x * 0.01) * 0.2);

      const g = ctx.createRadialGradient(
        -f.size * 0.3, -f.size * 0.3, 1,
        0, 0, f.size
      );
      g.addColorStop(0, "#fff6c2");
      g.addColorStop(0.5, "#ffc94d");
      g.addColorStop(1, "#c98900");

      ctx.fillStyle = g;
      ctx.beginPath();
      ctx.ellipse(0, 0, f.size * 1.2, f.size, 0, 0, Math.PI * 2);
      ctx.fill();

      // glossy highlight
      ctx.fillStyle = "rgba(255,255,255,0.5)";
      ctx.beginPath();
      ctx.ellipse(-f.size * 0.3, -f.size * 0.3, f.size * 0.4, f.size * 0.25, 0, 0, Math.PI * 2);
      ctx.fill();

      ctx.restore();
    }

    for (const f of fishes) f.draw();
    drawFlowers();
    drawRain();

    // UI overlays (on top of game)
    drawHints();
    drawMuteIcon();

    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

})();
</script>
  <!-- Cloudflare Web Analytics --><script defer src='https://static.cloudflareinsights.com/beacon.min.js' data-cf-beacon='{"token": "3c5ac2ad7f0a4bf2b52c11e92f3ca1cf"}'></script><!-- End Cloudflare Web Analytics -->
</body>
</html>
