<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Zen Pond</title>
<style>
html,body{
  margin:0;
  height:100%;
  overflow:hidden;
  background:#021018;
}
canvas{
  display:block;
  width:100vw;
  height:100vh;
}
</style>
</head>
<body>
<canvas id="c"></canvas>

<script>
(() => {
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");

  let W, H;
  const settings = {
    sound: true
  };

  function resize() {
    const dpr = Math.min(2, window.devicePixelRatio || 1);
    W = innerWidth;
    H = innerHeight;
    canvas.width = W * dpr;
    canvas.height = H * dpr;
    canvas.style.width = W + "px";
    canvas.style.height = H + "px";
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  addEventListener("resize", resize);
  resize();

  const rand = (a, b) => a + Math.random() * (b - a);
  const dist2 = (ax, ay, bx, by) => {
    let dx = bx - ax,
      dy = by - ay;
    return dx * dx + dy * dy
  };

  /* =============================
     BACKGROUND
  ============================= */

  function drawWater() {
    const g = ctx.createLinearGradient(0, 0, 0, H);
    g.addColorStop(0, "#0a2a43");
    g.addColorStop(0.5, "#062033");
    g.addColorStop(1, "#021018");
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, W, H);
  }

  /** =============================
     AUDIO
  ============================= */

  let audioCtx = null;
  let dropSound = null;

  function initAudio() {
    if (!audioCtx) {
      audioCtx = new(window.AudioContext || window.webkitAudioContext)();

      fetch('drop.mp3')
        .then(response => response.arrayBuffer())
        .then(arrayBuffer => audioCtx.decodeAudioData(arrayBuffer))
        .then(audioBuffer => {
          dropSound = audioBuffer;
        })
        .catch(err => console.log('Sound file not loaded:', err));
    }
  }

  function playDroplet(x) {
    // Check if settings exists and sound is enabled
    if (!audioCtx || !settings.sound || !dropSound) return;

    // Resume context if suspended by browser
    if (audioCtx.state === 'suspended') {
      audioCtx.resume();
    }

    const source = audioCtx.createBufferSource();
    const gain = audioCtx.createGain();
    const pan = audioCtx.createStereoPanner();

    source.buffer = dropSound;
    gain.gain.value = 0.4;
    pan.pan.value = (x / W) * 2 - 1;

    source.connect(gain).connect(pan).connect(audioCtx.destination);
    source.start();
  }

  /* =============================
     FOOD + SAFE RIPPLES
  ============================= */

  const foods = [];
  const ripples = [];
  let flow = 0;

  canvas.addEventListener("pointerdown", e => {
    initAudio();
    foods.push({
      x: e.clientX,
      y: e.clientY,
      size: 8
    });
    ripples.push({
      x: e.clientX,
      y: e.clientY,
      life: 0,
      maxLife: 2.5,
      baseRadius: 10
    });
    playDroplet(e.clientX);
  });

  function updateFood(dt) {
    flow += dt * 0.2;
    for (const f of foods) {
      f.x += Math.sin(flow + f.y * 0.02) * 8 * dt;
      f.y += Math.cos(flow + f.x * 0.02) * 4 * dt;
    }
  }

  function updateRipples(dt) {
    for (const r of ripples) {
      r.life += dt;
    }
    for (let i = ripples.length - 1; i >= 0; i--) {
      if (ripples[i].life > ripples[i].maxLife) {
        ripples.splice(i, 1);
      }
    }
  }

  /* =============================
     FISH
  ============================= */

  class Fish {
    constructor() {
      this.x = rand(0, W);
      this.y = rand(0, H);
      const a = rand(0, Math.PI * 2);
      this.baseSpeed = rand(45, 75);
      this.sizeScale = rand(0.8, 1.2);
      this.vx = Math.cos(a) * this.baseSpeed;
      this.vy = Math.sin(a) * this.baseSpeed;
      this.tail = rand(0, Math.PI * 2);
      const hue = rand(0, 360);
      this.color = `hsl(${hue},60%,80%)`;
    }

    update(dt, fishes) {
      // --- Boids-style flocking (cohesion, alignment, separation) ---
      const perception = 90;
      const separationDist = 34;
      const perception2 = perception * perception;
      const separation2 = separationDist * separationDist;

      let cohX = 0, cohY = 0, aliX = 0, aliY = 0, sepX = 0, sepY = 0;
      let count = 0;

      for (const other of fishes) {
        if (other === this) continue;
        const d2v = dist2(this.x, this.y, other.x, other.y);
        if (d2v > perception2) continue;

        count++;
        cohX += other.x;
        cohY += other.y;
        aliX += other.vx;
        aliY += other.vy;

        if (d2v < separation2 && d2v > 0.0001) {
          const dx = this.x - other.x;
          const dy = this.y - other.y;
          // Weighted stronger when closer
          const inv = 1 / d2v;
          sepX += dx * inv;
          sepY += dy * inv;
        }
      }

      // Helper to limit a vector magnitude
      const limit = (x, y, max) => {
        const m = Math.hypot(x, y) || 1;
        if (m <= max) return [x, y];
        const s = max / m;
        return [x * s, y * s];
      };

      let steerX = 0;
      let steerY = 0;

      if (count > 0) {
        // Cohesion: steer toward average position
        cohX = cohX / count - this.x;
        cohY = cohY / count - this.y;
        let m = Math.hypot(cohX, cohY) || 1;
        cohX = (cohX / m) * this.baseSpeed - this.vx;
        cohY = (cohY / m) * this.baseSpeed - this.vy;
        [cohX, cohY] = limit(cohX, cohY, 120);

        // Alignment: steer toward average velocity
        aliX /= count;
        aliY /= count;
        m = Math.hypot(aliX, aliY) || 1;
        aliX = (aliX / m) * this.baseSpeed - this.vx;
        aliY = (aliY / m) * this.baseSpeed - this.vy;
        [aliX, aliY] = limit(aliX, aliY, 140);

        // Separation: steer away from close neighbors
        m = Math.hypot(sepX, sepY) || 1;
        sepX = (sepX / m) * this.baseSpeed - this.vx;
        sepY = (sepY / m) * this.baseSpeed - this.vy;
        [sepX, sepY] = limit(sepX, sepY, 180);

        // Weights tuned to keep the same calm "Zen" feel
        steerX += cohX * 0.55 + aliX * 0.75 + sepX * 1.15;
        steerY += cohY * 0.55 + aliY * 0.75 + sepY * 1.15;
      }

      // --- Food attraction (kept from original, just layered on top) ---
      let nearest = null;
      let nearestDist = Infinity;

      for (const f of foods) {
        const d2v = dist2(this.x, this.y, f.x, f.y);
        if (d2v < nearestDist) {
          nearestDist = d2v;
          nearest = f;
        }
      }

      if (nearest) {
        const dx = nearest.x - this.x;
        const dy = nearest.y - this.y;
        const d = Math.hypot(dx, dy) || 1;
        const pull = 220 * (1 - Math.min(d / 420, 1));
        steerX += (dx / d) * pull;
        steerY += (dy / d) * pull;

        if (d < 15) {
          nearest.size -= 40 * dt;
          if (nearest.size <= 0) {
            foods.splice(foods.indexOf(nearest), 1);
          }
        }
      }

      // Gentle wander so schools don't become too rigid
      steerX += Math.cos(this.tail * 0.6) * 18;
      steerY += Math.sin(this.tail * 0.6) * 18;

      this.vx += steerX * dt;
      this.vy += steerY * dt;

      // Keep speed steady (original vibe), but allow tiny variation
      const speed = Math.hypot(this.vx, this.vy) || 1;
      const target = this.baseSpeed;
      this.vx = (this.vx / speed) * target;
      this.vy = (this.vy / speed) * target;

      this.x += this.vx * dt;
      this.y += this.vy * dt;

      if (this.x < 0) this.x = W;
      if (this.x > W) this.x = 0;
      if (this.y < 0) this.y = H;
      if (this.y > H) this.y = 0;

      this.tail += dt * 8;
    }

    draw() {
      const ang = Math.atan2(this.vy, this.vx);
      ctx.save();
      ctx.translate(this.x, this.y);
      ctx.rotate(ang);

      ctx.fillStyle = this.color;

      ctx.beginPath();
      ctx.ellipse(0, 0, 12 * this.sizeScale, 6 * this.sizeScale, 0, 0, Math.PI * 2);
      ctx.fill();

      const tailSwish = Math.sin(this.tail) * 6 * this.sizeScale;

      ctx.beginPath();
      ctx.moveTo(-12 * this.sizeScale, 0);
      ctx.lineTo(-22 * this.sizeScale, -6 * this.sizeScale + tailSwish);
      ctx.lineTo(-22 * this.sizeScale, 6 * this.sizeScale + tailSwish);
      ctx.closePath();
      ctx.fill();

      ctx.restore();
    }
  }

  const fishes = [];
  for (let i = 0; i < 25; i++) fishes.push(new Fish());

  /* =============================
     FLOWERS
  ============================= */

  const flowers = [];
  for (let i = 0; i < 12; i++) {
    flowers.push({
      x: rand(0, W),
      y: rand(0, H),
      rot: rand(0, Math.PI * 2),
      driftX: rand(-10, 10),
      driftY: rand(5, 20),
      petals: Math.floor(rand(5, 9)),
      size: rand(8, 24),
      rotSpeed: rand(0.1, 0.6),
      color: Math.random() < 0.5
        ? "rgba(255,255,255,0.95)"     // white
        : "rgba(255,182,193,0.9)"      // pink
    });

  }

  function updateFlowers(dt) {
    for (const f of flowers) {
      f.x += f.driftX * dt;
      f.y += f.driftY * dt;
      f.rot += dt * f.rotSpeed;

      if (f.y > H + 50) {
        f.y = -50;
        f.x = rand(0, W);
      }

      if (f.x < -50) f.x = W + 50;
      if (f.x > W + 50) f.x = -50;
    }
  }

  function drawFlowers() {
    for (const f of flowers) {
      // --- Draw Shadow First ---
      ctx.save();
      // Shift shadow slightly down and to the right
      ctx.translate(f.x + 15, f.y + 15); 
      ctx.rotate(f.rot);
      
      // Use a very soft, dark blue/black for water shadows
      ctx.fillStyle = "rgba(0, 0, 0, 0.2)"; 
      
      for (let i = 0; i < f.petals; i++) {
        ctx.save();
        ctx.rotate((Math.PI * 2 / f.petals) * i);
        ctx.beginPath();
        // Match the petal shape of the main flower
        ctx.ellipse(f.size * 0.6, 0, f.size, f.size * 0.5, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }
      ctx.restore();

      // --- Draw Main Flower ---
      ctx.save();
      ctx.translate(f.x, f.y);
      ctx.rotate(f.rot);

      // Keeping your original glow/blur for the flower itself
      ctx.shadowColor = "rgba(0,0,0,0.15)";
      ctx.shadowBlur = 10;

      for (let i = 0; i < f.petals; i++) {
        ctx.save();
        ctx.rotate((Math.PI * 2 / f.petals) * i);
        ctx.fillStyle = f.color;
        ctx.beginPath();
        ctx.ellipse(f.size * 0.6, 0, f.size, f.size * 0.5, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }

      // Center of the flower
      ctx.fillStyle = "rgba(255,220,120,0.95)";
      ctx.beginPath();
      ctx.arc(0, 0, f.size * 0.5, 0, Math.PI * 2);
      ctx.fill();

      ctx.restore();
    }
  }
  /* =============================
     LOOP
  ============================= */

  let last = performance.now();

  function loop(now) {
    const dt = Math.min(0.033, (now - last) / 1000);
    last = now;

    drawWater();
    updateFood(dt);
    updateRipples(dt);
    updateFlowers(dt);

    for (const f of fishes) f.update(dt, fishes);

    /* SAFE ripple drawing */
    for (const r of ripples) {
      const t = r.life / r.maxLife;
      const ease = 1 - Math.pow(1 - t, 2);
      const radius = r.baseRadius + ease * 220;
      const alpha = 1 - t;

      ctx.save();
      ctx.lineWidth = 2 * (1 - t);
      ctx.strokeStyle = `rgba(255,255,255,${alpha*0.5})`;
      ctx.shadowColor = `rgba(255,255,255,${alpha*0.3})`;
      ctx.shadowBlur = 20 * (1 - t);

      for (let i = 0; i < 3; i++) {
        const ringRadius = radius - i * 18;
        if (ringRadius > 0) {
          ctx.beginPath();
          ctx.arc(r.x, r.y, ringRadius, 0, Math.PI * 2);
          ctx.stroke();
        }
      }

      ctx.restore();
    }

    for (const f of foods) {
      ctx.fillStyle = "yellow";
      ctx.beginPath();
      ctx.arc(f.x, f.y, f.size, 0, Math.PI * 2);
      ctx.fill();
    }

    for (const f of fishes) f.draw();
    drawFlowers();

    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

})();</script>
</body>
</html>
