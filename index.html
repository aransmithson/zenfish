<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Zen Pond</title>
<style>
html,body{
  margin:0;
  height:100%;
  overflow:hidden;
  background:#021018;
}
canvas{
  display:block;
  width:100vw;
  height:100vh;
}
</style>
</head>
<body>
<canvas id="c"></canvas>

<script>
(() => {
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");

  let W, H;
  const settings = {
    sound: true
  };

  function resize() {
    const dpr = Math.min(2, window.devicePixelRatio || 1);
    W = innerWidth;
    H = innerHeight;
    canvas.width = W * dpr;
    canvas.height = H * dpr;
    canvas.style.width = W + "px";
    canvas.style.height = H + "px";
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  addEventListener("resize", resize);
  resize();

  const rand = (a, b) => a + Math.random() * (b - a);
  const dist2 = (ax, ay, bx, by) => {
    let dx = bx - ax,
      dy = by - ay;
    return dx * dx + dy * dy
  };

  /* =============================
     BACKGROUND
  ============================= */

  function drawWater() {
    const g = ctx.createLinearGradient(0, 0, 0, H);
    g.addColorStop(0, "#0a2a43");
    g.addColorStop(0.5, "#062033");
    g.addColorStop(1, "#021018");
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, W, H);
  }

  /** =============================
     AUDIO
  ============================= */

  let audioCtx = null;
  let dropSound = null;

  function initAudio() {
    if (!audioCtx) {
      audioCtx = new(window.AudioContext || window.webkitAudioContext)();

      fetch('drop.mp3')
        .then(response => response.arrayBuffer())
        .then(arrayBuffer => audioCtx.decodeAudioData(arrayBuffer))
        .then(audioBuffer => {
          dropSound = audioBuffer;
        })
        .catch(err => console.log('Sound file not loaded:', err));
    }
  }

  function playDroplet(x) {
    // Check if settings exists and sound is enabled
    if (!audioCtx || !settings.sound || !dropSound) return;

    // Resume context if suspended by browser
    if (audioCtx.state === 'suspended') {
      audioCtx.resume();
    }

    const source = audioCtx.createBufferSource();
    const gain = audioCtx.createGain();
    const pan = audioCtx.createStereoPanner();

    source.buffer = dropSound;
    gain.gain.value = 0.4;
    pan.pan.value = (x / W) * 2 - 1;

    source.connect(gain).connect(pan).connect(audioCtx.destination);
    source.start();
  }

  /* =============================
     FOOD + SAFE RIPPLES
  ============================= */

  const foods = [];
  const ripples = [];
  const spookZones = []; // Zones that scare fish away
  let flow = 0;

  canvas.addEventListener("pointerdown", e => {
    initAudio();
    
    // Check if clicking on a flower first
    let clickedFlower = false;
    for (const f of flowers) {
      const dx = e.clientX - f.x;
      const dy = e.clientY - f.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      
      // Check if click is within flower radius (considering size and petals)
      if (distance < f.size * 1.5) {
        // Trigger spin
        f.spinning = true;
        f.currentRotSpeed = rand(8, 12); // Fast spin speed
        
        // Add spook zone to scare nearby fish
        spookZones.push({
          x: f.x,
          y: f.y,
          life: 0,
          maxLife: 1.2, // How long the spook effect lasts
          radius: 120   // How far the spook effect reaches
        });
        
        clickedFlower = true;
        break; // Only spin one flower per click
      }
    }
    
    // If didn't click a flower, add food and ripple as normal
    if (!clickedFlower) {
      foods.push({
        x: e.clientX,
        y: e.clientY,
        size: 8
      });
      ripples.push({
        x: e.clientX,
        y: e.clientY,
        life: 0,
        maxLife: 2.5,
        baseRadius: 10
      });
      playDroplet(e.clientX);
    }
  });

  function updateFood(dt) {
    flow += dt * 0.2;
    for (const f of foods) {
      f.x += Math.sin(flow + f.y * 0.02) * 8 * dt;
      f.y += Math.cos(flow + f.x * 0.02) * 4 * dt;
    }
  }

  function updateRipples(dt) {
    for (const r of ripples) {
      r.life += dt;
    }
    for (let i = ripples.length - 1; i >= 0; i--) {
      if (ripples[i].life > ripples[i].maxLife) {
        ripples.splice(i, 1);
      }
    }
  }

  function updateSpookZones(dt) {
    for (const z of spookZones) {
      z.life += dt;
    }
    for (let i = spookZones.length - 1; i >= 0; i--) {
      if (spookZones[i].life > spookZones[i].maxLife) {
        spookZones.splice(i, 1);
      }
    }
  }

  /* =============================
     FISH
  ============================= */

  class Fish {
    constructor() {
      this.x = rand(0, W);
      this.y = rand(0, H);
      const a = rand(0, Math.PI * 2);
      this.baseSpeed = rand(45, 75);
      this.sizeScale = rand(0.8, 1.2);
      this.vx = Math.cos(a) * this.baseSpeed;
      this.vy = Math.sin(a) * this.baseSpeed;
      this.tail = rand(0, Math.PI * 2);
      this.speedMultiplier = 1.0; // For fleeing speed boost
      
      // Classic koi color patterns
      const patterns = [
        { base: '#ffffff', accent: '#ff6b35', spots: true },  // Kohaku (white + red)
        { base: '#ffd700', accent: '#ff8c00', spots: false }, // Gold
        { base: '#ffffff', accent: '#ff1744', spots: true },  // White + deep red
        { base: '#ffe0b5', accent: '#ff6f00', spots: true },  // Cream + orange
        { base: '#ff6b6b', accent: '#8b0000', spots: false }, // Red
        { base: '#ffffff', accent: '#000000', spots: true },  // Shiro Utsuri (white + black)
      ];
      
      const pattern = patterns[Math.floor(Math.random() * patterns.length)];
      this.baseColor = pattern.base;
      this.accentColor = pattern.accent;
      this.hasSpots = pattern.spots;
      
      // Generate random spots if applicable
      this.spots = [];
      if (this.hasSpots) {
        const numSpots = Math.floor(rand(2, 5));
        for (let i = 0; i < numSpots; i++) {
          this.spots.push({
            x: rand(-8, 4),
            y: rand(-4, 4),
            size: rand(3, 7) * this.sizeScale
          });
        }
      }
    }

    update(dt, fishes) {
      // --- Boids-style flocking (cohesion, alignment, separation) ---
      const perception = 90;
      const separationDist = 34;
      const perception2 = perception * perception;
      const separation2 = separationDist * separationDist;

      let cohX = 0, cohY = 0, aliX = 0, aliY = 0, sepX = 0, sepY = 0;
      let count = 0;

      for (const other of fishes) {
        if (other === this) continue;
        const d2v = dist2(this.x, this.y, other.x, other.y);
        if (d2v > perception2) continue;

        count++;
        cohX += other.x;
        cohY += other.y;
        aliX += other.vx;
        aliY += other.vy;

        if (d2v < separation2 && d2v > 0.0001) {
          const dx = this.x - other.x;
          const dy = this.y - other.y;
          // Weighted stronger when closer
          const inv = 1 / d2v;
          sepX += dx * inv;
          sepY += dy * inv;
        }
      }

      // Helper to limit a vector magnitude
      const limit = (x, y, max) => {
        const m = Math.hypot(x, y) || 1;
        if (m <= max) return [x, y];
        const s = max / m;
        return [x * s, y * s];
      };

      let steerX = 0;
      let steerY = 0;

      if (count > 0) {
        // Cohesion: steer toward average position
        cohX = cohX / count - this.x;
        cohY = cohY / count - this.y;
        let m = Math.hypot(cohX, cohY) || 1;
        cohX = (cohX / m) * this.baseSpeed - this.vx;
        cohY = (cohY / m) * this.baseSpeed - this.vy;
        [cohX, cohY] = limit(cohX, cohY, 120);

        // Alignment: steer toward average velocity
        aliX /= count;
        aliY /= count;
        m = Math.hypot(aliX, aliY) || 1;
        aliX = (aliX / m) * this.baseSpeed - this.vx;
        aliY = (aliY / m) * this.baseSpeed - this.vy;
        [aliX, aliY] = limit(aliX, aliY, 140);

        // Separation: steer away from close neighbors
        m = Math.hypot(sepX, sepY) || 1;
        sepX = (sepX / m) * this.baseSpeed - this.vx;
        sepY = (sepY / m) * this.baseSpeed - this.vy;
        [sepX, sepY] = limit(sepX, sepY, 180);

        // Weights tuned to keep the same calm "Zen" feel
        steerX += cohX * 0.55 + aliX * 0.75 + sepX * 1.15;
        steerY += cohY * 0.55 + aliY * 0.75 + sepY * 1.15;
      }

      // --- Food attraction (kept from original, just layered on top) ---
      let nearest = null;
      let nearestDist = Infinity;

      for (const f of foods) {
        const d2v = dist2(this.x, this.y, f.x, f.y);
        if (d2v < nearestDist) {
          nearestDist = d2v;
          nearest = f;
        }
      }

      if (nearest) {
        const dx = nearest.x - this.x;
        const dy = nearest.y - this.y;
        const d = Math.hypot(dx, dy) || 1;
        const pull = 220 * (1 - Math.min(d / 420, 1));
        steerX += (dx / d) * pull;
        steerY += (dy / d) * pull;

        if (d < 15) {
          nearest.size -= 40 * dt;
          if (nearest.size <= 0) {
            foods.splice(foods.indexOf(nearest), 1);
          }
        }
      }

      // --- Spook avoidance (flee from clicked flowers) ---
      let isSpooked = false;
      for (const zone of spookZones) {
        const dx = this.x - zone.x;
        const dy = this.y - zone.y;
        const d = Math.hypot(dx, dy) || 1;
        
        if (d < zone.radius) {
          isSpooked = true;
          // Stronger flee force when closer, weaker as life increases
          const fadeOut = 1 - (zone.life / zone.maxLife);
          const distanceFactor = 1 - (d / zone.radius);
          const fleeStrength = 400 * fadeOut * distanceFactor;
          
          steerX += (dx / d) * fleeStrength;
          steerY += (dy / d) * fleeStrength;
        }
      }
      
      // Smooth speed multiplier with easing
      const targetMultiplier = isSpooked ? 1.3 : 1.0;
      const easeSpeed = isSpooked ? 0.25 : 0.03; // Fast to speed up, very slow to calm down
      this.speedMultiplier += (targetMultiplier - this.speedMultiplier) * easeSpeed;

      // Gentle wander so schools don't become too rigid
      steerX += Math.cos(this.tail * 0.6) * 18;
      steerY += Math.sin(this.tail * 0.6) * 18;

      this.vx += steerX * dt;
      this.vy += steerY * dt;

      // Keep speed steady but apply multiplier for fleeing
      const speed = Math.hypot(this.vx, this.vy) || 1;
      const target = this.baseSpeed * this.speedMultiplier;
      this.vx = (this.vx / speed) * target;
      this.vy = (this.vy / speed) * target;

      this.x += this.vx * dt;
      this.y += this.vy * dt;

      if (this.x < 0) this.x = W;
      if (this.x > W) this.x = 0;
      if (this.y < 0) this.y = H;
      if (this.y > H) this.y = 0;

      // Faster tail movement when fleeing
      this.tail += dt * 8 * this.speedMultiplier;
    }

    draw() {
      const ang = Math.atan2(this.vy, this.vx);
      ctx.save();
      ctx.translate(this.x, this.y);
      ctx.rotate(ang);

      // Shadow underneath fish for depth
      ctx.save();
      ctx.globalAlpha = 0.2;
      ctx.fillStyle = '#000000';
      ctx.beginPath();
      ctx.ellipse(1, 4, 11 * this.sizeScale, 5 * this.sizeScale, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();

      // Main body with gradient for 3D effect
      const bodyGradient = ctx.createRadialGradient(
        2, -1, 0,
        0, 0, 12 * this.sizeScale
      );
      bodyGradient.addColorStop(0, this.baseColor);
      bodyGradient.addColorStop(0.7, this.baseColor);
      bodyGradient.addColorStop(1, this.accentColor.replace(')', ', 0.3)').replace('#', 'rgba(').replace(/^rgba\(([^,]+)/, (m, hex) => {
        const r = parseInt(hex.slice(0, 2), 16);
        const g = parseInt(hex.slice(2, 4), 16);
        const b = parseInt(hex.slice(4, 6), 16);
        return `rgba(${r}, ${g}, ${b}`;
      }));
      
      ctx.fillStyle = bodyGradient;
      ctx.beginPath();
      ctx.ellipse(0, 0, 12 * this.sizeScale, 6 * this.sizeScale, 0, 0, Math.PI * 2);
      ctx.fill();

      // Add spots/patterns
      if (this.hasSpots) {
        ctx.fillStyle = this.accentColor;
        for (const spot of this.spots) {
          ctx.globalAlpha = 0.8;
          ctx.beginPath();
          ctx.ellipse(spot.x, spot.y, spot.size, spot.size * 0.8, rand(0, Math.PI), 0, Math.PI * 2);
          ctx.fill();
        }
        ctx.globalAlpha = 1;
      }

      // Subtle scales texture
      ctx.save();
      ctx.globalAlpha = 0.15;
      ctx.strokeStyle = this.accentColor;
      ctx.lineWidth = 0.5;
      for (let i = -8; i < 8; i += 3) {
        for (let j = -4; j < 4; j += 2.5) {
          ctx.beginPath();
          ctx.arc(i, j, 1.5 * this.sizeScale, 0, Math.PI * 2);
          ctx.stroke();
        }
      }
      ctx.restore();

// --- Koi Style Flowing Pectoral Fins (forward + gentle waggle) ---
ctx.globalAlpha = 0.8;

// Slow, elegant waggle (very subtle)
const finWaggle = Math.sin(this.tail * 0.8) * 3 * this.sizeScale;

// Move fins forward toward the head
const finOffsetX = 6 * this.sizeScale;

// Fin gradient
const finGradient = ctx.createRadialGradient(finOffsetX, 0, 0, finOffsetX, 0, 16 * this.sizeScale);
finGradient.addColorStop(0, this.baseColor);
finGradient.addColorStop(1, this.accentColor.replace(')', ', 0.4)').replace('#', 'rgba(').replace(/^rgba\(([^,]+)/, (m, hex) => {
  const r = parseInt(hex.slice(0, 2), 16);
  const g = parseInt(hex.slice(2, 4), 16);
  const b = parseInt(hex.slice(4, 6), 16);
  return `rgba(${r}, ${g}, ${b}`;
}));

ctx.fillStyle = finGradient;

// Top flowing fin
ctx.beginPath();
ctx.moveTo(finOffsetX, -3 * this.sizeScale);
ctx.quadraticCurveTo(
  -16 * this.sizeScale,
  -14 * this.sizeScale + finWaggle,
  -4 * this.sizeScale,
  -2 * this.sizeScale
);
ctx.quadraticCurveTo(
  2 * this.sizeScale,
  -6 * this.sizeScale,
  finOffsetX,
  -3 * this.sizeScale
);
ctx.fill();

// Bottom flowing fin
ctx.beginPath();
ctx.moveTo(finOffsetX, 3 * this.sizeScale);
ctx.quadraticCurveTo(
  -16 * this.sizeScale,
  14 * this.sizeScale - finWaggle,
  -4 * this.sizeScale,
  2 * this.sizeScale
);
ctx.quadraticCurveTo(
  2 * this.sizeScale,
  6 * this.sizeScale,
  finOffsetX,
  3 * this.sizeScale
);
ctx.fill();

ctx.globalAlpha = 1;

      // Tail with gradient
      const tailSwish = Math.sin(this.tail) * 6 * this.sizeScale;
      const tailGradient = ctx.createLinearGradient(-12 * this.sizeScale, 0, -22 * this.sizeScale, 0);
      tailGradient.addColorStop(0, this.baseColor);
      tailGradient.addColorStop(1, this.accentColor);
      
      ctx.fillStyle = tailGradient;
      ctx.globalAlpha = 0.9;
      ctx.beginPath();
      ctx.moveTo(-12 * this.sizeScale, 0);
      ctx.lineTo(-22 * this.sizeScale, -6 * this.sizeScale + tailSwish);
      ctx.lineTo(-22 * this.sizeScale, 6 * this.sizeScale + tailSwish);
      ctx.closePath();
      ctx.fill();
      ctx.globalAlpha = 1;

      // Eye
      ctx.fillStyle = '#000000';
      ctx.beginPath();
      ctx.arc(8 * this.sizeScale, -1.5 * this.sizeScale, 1.2 * this.sizeScale, 0, Math.PI * 2);
      ctx.fill();
      
      // Eye highlight
      ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
      ctx.beginPath();
      ctx.arc(8.3 * this.sizeScale, -1.8 * this.sizeScale, 0.5 * this.sizeScale, 0, Math.PI * 2);
      ctx.fill();

      ctx.restore();
    }
  }

  const fishes = [];
  for (let i = 0; i < 25; i++) fishes.push(new Fish());

  /* =============================
     FLOWERS
  ============================= */

  const flowers = [];
  for (let i = 0; i < 12; i++) {
    const baseRotSpeed = rand(0.1, 0.6);
    flowers.push({
      x: rand(0, W),
      y: rand(0, H),
      rot: rand(0, Math.PI * 2),
      driftX: rand(-10, 10),
      driftY: rand(5, 20),
      petals: Math.floor(rand(5, 9)),
      size: rand(8, 24),
      rotSpeed: baseRotSpeed,
      baseRotSpeed: baseRotSpeed,
      currentRotSpeed: baseRotSpeed,
      spinning: false,
      color: Math.random() < 0.5
        ? "rgba(255,255,255,0.95)"     // white
        : "rgba(255,182,193,0.9)"      // pink
    });

  }

  function updateFlowers(dt) {
    for (const f of flowers) {
      f.x += f.driftX * dt;
      f.y += f.driftY * dt;
      
      // Handle spinning - gradually slow down to normal speed
      if (f.spinning) {
        f.currentRotSpeed = f.currentRotSpeed * 0.98; // Slow down gradually
        if (f.currentRotSpeed <= f.baseRotSpeed * 1.1) {
          f.spinning = false;
          f.currentRotSpeed = f.baseRotSpeed;
        }
      }
      
      f.rot += dt * f.currentRotSpeed;

      if (f.y > H + 50) {
        f.y = -50;
        f.x = rand(0, W);
      }

      if (f.x < -50) f.x = W + 50;
      if (f.x > W + 50) f.x = -50;
    }
  }

  function drawFlowers() {
    for (const f of flowers) {
      // --- Draw Shadow First ---
      ctx.save();
      // Shift shadow slightly down and to the right
      ctx.translate(f.x + 15, f.y + 15); 
      ctx.rotate(f.rot);
      
      // Use a very soft, dark blue/black for water shadows
      ctx.fillStyle = "rgba(0, 0, 0, 0.2)"; 
      
      for (let i = 0; i < f.petals; i++) {
        ctx.save();
        ctx.rotate((Math.PI * 2 / f.petals) * i);
        ctx.beginPath();
        // Match the petal shape of the main flower
        ctx.ellipse(f.size * 0.6, 0, f.size, f.size * 0.5, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }
      ctx.restore();

      // --- Draw Main Flower ---
      ctx.save();
      ctx.translate(f.x, f.y);
      ctx.rotate(f.rot);

      // Keeping your original glow/blur for the flower itself
      ctx.shadowColor = "rgba(0,0,0,0.15)";
      ctx.shadowBlur = 10;

      for (let i = 0; i < f.petals; i++) {
        ctx.save();
        ctx.rotate((Math.PI * 2 / f.petals) * i);
        ctx.fillStyle = f.color;
        ctx.beginPath();
        ctx.ellipse(f.size * 0.6, 0, f.size, f.size * 0.5, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }

      // Center of the flower
      ctx.fillStyle = "rgba(255,220,120,0.95)";
      ctx.beginPath();
      ctx.arc(0, 0, f.size * 0.5, 0, Math.PI * 2);
      ctx.fill();

      ctx.restore();
    }
  }
  /* =============================
     LOOP
  ============================= */

  let last = performance.now();

  function loop(now) {
    const dt = Math.min(0.033, (now - last) / 1000);
    last = now;

    drawWater();
    updateFood(dt);
    updateRipples(dt);
    updateSpookZones(dt);
    updateFlowers(dt);

    for (const f of fishes) f.update(dt, fishes);

    /* SAFE ripple drawing */
    for (const r of ripples) {
      const t = r.life / r.maxLife;
      const ease = 1 - Math.pow(1 - t, 2);
      const radius = r.baseRadius + ease * 220;
      const alpha = 1 - t;

      ctx.save();
      ctx.lineWidth = 2 * (1 - t);
      ctx.strokeStyle = `rgba(255,255,255,${alpha*0.5})`;
      ctx.shadowColor = `rgba(255,255,255,${alpha*0.3})`;
      ctx.shadowBlur = 20 * (1 - t);

      for (let i = 0; i < 3; i++) {
        const ringRadius = radius - i * 18;
        if (ringRadius > 0) {
          ctx.beginPath();
          ctx.arc(r.x, r.y, ringRadius, 0, Math.PI * 2);
          ctx.stroke();
        }
      }

      ctx.restore();
    }

    for (const f of foods) {
      ctx.fillStyle = "yellow";
      ctx.beginPath();
      ctx.arc(f.x, f.y, f.size, 0, Math.PI * 2);
      ctx.fill();
    }

    for (const f of fishes) f.draw();
    drawFlowers();

    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

})();</script>
</body>
</html>